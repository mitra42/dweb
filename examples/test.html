<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Test page for Dweb</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script><!-- get JQUERY from google -->
    <!--<script src="/file/sb/SHA3256B64URL.BDCbn_l9rrlCdVkB9o6qozSP84HBCGors5dBLxdyro8="></script><!-- jquery-3.1.1.js-->
    <script src="/file/mb/SHA3256B64URL.OylzjhbKQK5VOVMbvdK9Dkb4UDfOEHU8uCeSnzqiseE="></script>--><!-- dweb.js -->
    <script>
        // This is code intended to go in library when working
        // ====== IN PROGRESS BELOW HERE
        //var dwebserver = '192.168.1.156'
        var dwebserver = 'localhost'
        var dwebport = '4243'

        class TransportHttp {

            constructor(ipandport, options) {
                this.ipandport = ipandport;
                this.options = options; // Dictionary of options, currently unused
                this.baseurl = "http://" + ipandport[0] + ":" + ipandport[1] + "/";
            }

            static setup(ipandport, options) {
                return new TransportHttp(ipandport, options);
            }


            list(self, table, hash, verbose, options) {
                // obj being loaded
                // table: overrides table of class
                // optioms: are passed to class specific onloaded
                // Locate and return a block, based on its multihash
                if (verbose) { console.log("TransportHTTP:list: table=", table, "hash=", hash); }
                let url = this.url("list", table, hash);
                if (verbose) { console.log("TransportHTTP:list: url=",url); }
                $.ajax({
                    type: "GET",
                    url: url,
                    success: function(data) {
                        if (verbose) { console.log("TransportHTTP:list: returning data len=", data.length); }
                        // Dont appear to need to parse JSON data, its decoded already
                        self.onloaded(data, verbose, options);
                    },
                    error: function(xhr, status, error) {
                        console.log("TransportHTTP:list: error", status, "error=",error);
                        alert("TODO Block failure status="+status+" error="+error);
                    },
                });
            }


            url(command, table, hash) {
                var url = this.baseurl + command + "/" + table + "/" + hash;
                return url;
            }
        }

        var transport = TransportHttp.setup([dwebserver, dwebport], {});

        class Block {
            constructor(hash, data) {
                this._hash = hash;  // Maybe null
                this._data = data;  // Maybe null
                this._table = 'b';
            }

            onloaded(verbose, options) {
                // Called after block succeeds, can pass options through
                if (verbose) { console.log("Block:onloaded:Storing _data to", options["dom_id"]); }
                if (options["dom_id"]) {
                            document.getElementById(options["dom_id"]).innerHTML = this._data;
                } // TODO make it handle img, or other non-HTML as reqd
            }

            block(table, verbose, options) {    //TODO merge with transport.list
                // table: overrides table of class
                // options: { dom_id:   id to put data retrieved.
                //TODO probably move this into transportHttp but leave success and failure out passing object to call as parameter
                // Based on python except table is reqd parameter (null not acceptable)
                // Locate and return a block, based on its multihash
                if (verbose) { console.log("Fetching block: table=", table || this._table, "hash=", this._hash); }
                let url = transport.url("block", table || this._table, this._hash);
                if (verbose) { console.log("Fetching block: url=",url); }
                let self = this;    // So can pass to success function
                $.ajax({
                    type: "GET",
                    url: url,
                    success: function(data) {
                        if (verbose) { console.log("Block returning data len=", data.length); }
                        self._data = data;
                        self.onloaded(verbose, options);
                    },
                    error: function(xhr, status, error) {
                        console.log("TransportHTTP:list: error", status, "error=",error);
                        alert("TODO Block failure status="+status+" error="+error);
                    },
                });
            }
        }

        class StructuredBlock extends Block { //TODO can subclass SmartDict if used elsewhere
            constructor(hash) { //TODO support other things in construction
                super(hash, null); // _hash is _hash of SB, not of data
                this._table = "sb"; // Note this is cls.table on python but need to separate from dictionary
            }
            load(verbose, options) {
                // Locate and return a block, based on its multihash
                if (verbose) { console.log("Fetching StructuredBlock table=",this._table,"hash=",this._hash); }
                this.block(null, verbose, options);
                // Block fetched in the background - dont assume loaded here
            }
            onloaded(verbose, options) {
                this._dict = JSON.parse(this._data);
                if (options["dom_id"]) {
                    if (verbose) { console.log("StructuredBlock:onloaded:Storing data to", options["dom_id"]); }
                    document.getElementById(options["dom_id"]).innerHTML = this._dict["data"];
                } // TODO make it handle img, or other non-HTML as reqd based on this._dict["Content-type"]
                if (options["elem"]) {
                    if (verbose) { console.log("StructuredBlock:onloaded:Storing data to element"); }
                    options["elem"].innerHTML = this._dict["data"];
                } // TODO make it handle img, or other non-HTML as reqd based on this._dict["Content-type"]
            }
        }
        class Signature {
            constructor(dic) {
                this.date = dic["date"];
                this.hash = dic["hash"];
                this.publickey = dic["publickey"];
                this.signature = dic["signature"]
                //console.log("Signature created",this.hash);
            }
            //TODO need to be able to verify signatures
        }

        class SignedBlock {
            // TODO Build Signed Block - allow retrieval of SB from it

            constructor(hash) { // Python also handles, structuredblock=None, signatures=None, verbose=False, **options):
                // Adapted from Python SignedBlock
                // if structuredblock and not isinstance(structuredblock, StructuredBlock):
                //     structuredblock = StructuredBlock(structuredblock) # Handles dict or json of dict
                this._structuredblock = null; // Would be from structuredblock if passed
                this._hash = hash;              // Hash of structured block
                this._signatures = new Array(); //Would initialize to Signatures(signatures or [])
                this._date = null;
            }

            load(verbose, options) {
                if (this._structuredblock) {
                    this._structuredblock.onloaded(options);
                } else {
                    sb = new StructuredBlock(this._hash);
                    sb.load(verbose, options);    // Asynchronous load - calls SB.onloaded
                }
            }


            earliestdate() {
                if (!this._signatures) {
                    this._date = null;
                } else {
                    if (!this._date) {
                        this._date = this._signatures[0]["date"];
                        for (let i = 1; this._signatures.length > i; i++) {
                            if ( this._date > this._signatures[i]["date"]) {
                                this._date = this._signatures[i]["date"];
                            }
                        }
                    }
                }
                return this._date;
            }

            static compare(a, b) {
                if (a.earliestdate() > b.earliestdate()) { return 1; }
                if (b.earliestdate() > a.earliestdate()) { return -1; }
                return 0;
            }
        }

        class MutableBlock {
            // TODO Build MutableBlock - allow fetch of signatures, and fetching them
            // TODO allow fetching of most recent

            constructor(hash) {
                // Note python __init__ also allows constructing with key, or with neither key nor hash
                this._hash = hash;       // Could be None
                this._key = null;
                this._current = null;
                this._prev = new Array();
            }

            load(verbose, options) {   // Python can also fetch based on just having key
                transport.list(this, "signedby", this._hash, verbose, options);
            }

            onloaded(lines, verbose, options) {
                let results = {};
                for (let i in lines) {
                    let s = new Signature(lines[i]);
                    if (! results[s.hash]) {
                        results[s.hash] = new SignedBlock(s.hash);
                    }
                    //TODO turn s.date into java date
                    //if isinstance(s.date, basestring):
                    //    s.date = dateutil.parser.parse(s.date)
                    //TODO verify signature
                    //if CryptoLib.verify(s):
                    results[s.hash]._signatures.push(s);
                }
                let sbs = new Array();
                for (let k in results) {
                    sbs.push(results[k]);      // Array of SignedBlock
                }
                //TODO sort list
                sbs.sort(SignedBlock.compare);

                //sbs.sort(function(a, b) {
                //    if (a.earliestdate() > b.earliestdate()) { return -1; }
                //    if (b.earliestdate() > a.earliestdate()) { return 1; }
                //    return 0; })
                this._current = sbs.pop();
                this._prev = sbs;
                if (options["dom_id"]) {
                    if (verbose) { console.log("MutableBlock:onloaded:Storing data to", options["dom_id"]); }
                    let ul = document.getElementById(options["dom_id"]);
                    this.updatelist(ul, verbose);
                } // TODO make it handle img, or other non-HTML as reqd based on this._dict["Content-type"]
            }

            updatelist(ul, verbose) {
                while (ul.hasChildNodes()) {
                    ul.removeChild(ul.lastChild);
                }
                for (let ii in this._prev) {     // Signed Blocks
                    let i = this._prev[ii];
                    let li = document.createElement("li");
                    ul.appendChild(li);
                    i.load(verbose, { "elem": li });
                }
                let li = document.createElement("li");
                ul.appendChild(li);
                this._current.load(verbose, { "elem": li });
            }
        }

        class MutableBlockMaster {
            // TODO Build MutableBlockMaster - allow to drive editor (MCE)
        }

    </script>
    <script>
        // This is my current testing script first of block
        console.log("Block=======");
        let b = new Block("SHA3256B64URL.50GNWgUQ9GgrVfMvpedEg77ByMRYkUgPRU9P1gWaNF8=", null); // Block with "clever dog..."
        b.block(null, true, {"dom_id": "myList.0"});      // Load block in background
        // Now of SB
        console.log("StructuredBlock=======");
        let sb = new StructuredBlock("SHA3256B64URL.aX4-6I6Ck0ZX9A2CgNpsBakD-GkRiCC8Aivm_ROegrM=");
        sb.load(true, {"dom_id": "myList.1"} ); // hash of SB containing data containing "I'm a paragraph" // Load SB in background
        // Now MB
        console.log("MutableBlock=======");
        var mb = new MutableBlock("SHA3256B64URL.CLw7p4lteb5oxmXBkuk9lDqM89hRic7RPITGWg1AAD4=");
        mb.load(true, {"dom_id": "List2"});
    </script>


</head>
<body>
<H1>Test page for DWEB</H1>
<p>This page is a current test, will just be testing current (usually broken) stuff.</p>

<ul id="myList"><li id="myList.0">Initial unreplaced text</li><li id="myList.1">Dummy text of item1</li></ul>
<h4>Second list</h4>
<ul id="List2"><li>What was there before</li></ul>
</body>
</html>

